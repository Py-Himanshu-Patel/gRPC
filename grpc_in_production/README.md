# gRPC in Production

## Testing a gRPC Server
The server-side testing consists of starting a gRPC server with the required  gRPC service and then 
connecting to the server using the client application where you implement your test cases.

One special thing about the server-side gRPC tests is that they require the server application to open 
up a port  the client application connects to. If you prefer not to do this, or your testing environment 
doesn’t allow it, you can use a library to help avoid starting up a service with a real port number. 
In Go, you can use the `bufconn package`.

## Testing a gRPC Client
To test client-side logic without the overhead of  connecting to a real server, you can use a mocking 
framework. Mocking of the gRPC server side enables developers to write lightweight unit tests to check 
functionalities  on the client side without invoking RPC calls to a server.

Check this file for server: `grpc_in_production/server/main.go`
Check this file for server test: `grpc_in_production/server/prodinfo_test.go`

Run test using
```bash
# grpc_in_production/server
$ go test .
```
Here we tested `AddProduct` using both HTTP server connection (actually starting a server in gorouting) and 
using mock/buffer (without starting a server). 

If you are developing a gRPC client application with Go, you can use `Gomock` to  mock the client interface 
(using the generated code) and programmatically set its methods to expect and return predetermined values. 
Using `Gomock`, you can generate mock interfaces for the gRPC client application using:
```bash
$ mockgen grpc_prod/proto-gen ProductInfoClient > mock_prodinfo/prodinfo_mock.go
```

Here, we’ve specified `ProductInfoClient` as the interface to be mocked. Then the test code you write can 
import the package generated by `mockgen` along with the `gomock` package to write unit tests around client-side logic.

Package generated by mockgen: `grpc_in_production/mock_prodinfo/prodinfo_mock.go`
Package for testing mockgen generated package: `grpc_in_production/mock_prodinfo/prodinfo_mock_test.go`

```bash
# ProductInfoClient interface inside productinfo_grpc.pb.go
# this will be mocked in prodinfo_mock.go generated package

type ProductInfoClient interface {
	AddProduct(ctx context.Context, in *Product, opts ...grpc.CallOption) (*ProductID, error)
	GetProduct(ctx context.Context, in *ProductID, opts ...grpc.CallOption) (*Product, error)
}
```

In practice, you can verify a selected set of capabilities via mocking and the rest needs to be verified against 
the actual gRPC server implementation.

## Load Testing
we need tailor-made load-testing tools that can load test the gRPC server by generating a virtual load of RPCs to the server.

`ghz` is such a load-testing tool; it is implemented as a command-line utility using Go. 
It can be used for testing and debugging services locally, and also in automated continuous integration environments for performance regression testing.

- Download `ghz` from https://github.com/bojand/ghz/releases with name  *ghz-linux-x86_64.tar.gz*
- Extract and place the binaries in `/usr/local/ghz`
```bash
$ ls /usr/local/ghz/
ghz  ghz-web  LICENSE
```
- Set the `PATH` to these binaries
```bash
# ~/.bashrc

# ghz binary - grpc load testing
export PATH="$PATH:/usr/local/ghz/"
```

Run below command after starting server 
- `insecure` means insecure command
- `--proto` location to .proto file from current location
- `--call` Packagename.ServiceName.MethodName in protofile
- `-d` data which need to sent in request as a valid json string
- `-n` number of request to invoke
- `-c` no of goroutines to spin **Server should be thread safe for this or it will exit with error and client will see `Connection Refused`**
- `0.0.0.0:50051` is the host and port on which server is listening

```bash
#$ pwd
#/home/lenovo/dev/gRPC/grpc_in_production

ghz --insecure --proto proto-gen/product_info.proto --call ecommerce.ProductInfo.addProduct -d '{"id":"1","name":"Joe","description":"First Description","price":100}' -n 200 -c 20 0.0.0.0:50051

Summary:
  Count:        200
  Total:        12.47 ms
  Slowest:      2.61 ms
  Fastest:      0.09 ms
  Average:      0.57 ms
  Requests/sec: 16033.62

Response time histogram:
  0.089 [1]  |∎
  0.341 [63] |∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  0.593 [57] |∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  0.845 [46] |∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  1.097 [18] |∎∎∎∎∎∎∎∎∎∎∎
  1.349 [4]  |∎∎∎
  1.601 [7]  |∎∎∎∎
  1.854 [1]  |∎
  2.106 [2]  |∎
  2.358 [0]  |
  2.610 [1]  |∎

Latency distribution:
  10 % in 0.18 ms 
  25 % in 0.29 ms 
  50 % in 0.50 ms 
  75 % in 0.74 ms 
  90 % in 0.98 ms 
  95 % in 1.36 ms 
  99 % in 1.86 ms 

Status code distribution:
  [OK]   200 responses   
```

## Continuous Integration
When it comes to gRPC applications, often the server- and client-side
applications are independent and may be built with disparate technologies. So, as part
of the CI process, you will have to verify the gRPC client- or server-side code using
the unit and integration testing techniques that we learned in the previous section.

For instance, if you have written tests using Go, then you can easily
integrate your Go tests with tools such as Jenkins, TravisCI, Spinnaker, etc.

## Deployment

### Deploying on Docker

### Deploying on Kubernetes
