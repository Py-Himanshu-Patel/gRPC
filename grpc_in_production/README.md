# gRPC in Production

## Testing a gRPC Server
The server-side testing consists of starting a gRPC server with the required  gRPC service and then 
connecting to the server using the client application where you implement your test cases.

One special thing about the server-side gRPC tests is that they require the server application to open 
up a port  the client application connects to. If you prefer not to do this, or your testing environment 
doesn’t allow it, you can use a library to help avoid starting up a service with a real port number. 
In Go, you can use the `bufconn package`.

## Testing a gRPC Client
To test client-side logic without the overhead of  connecting to a real server, you can use a mocking 
framework. Mocking of the gRPC server side enables developers to write lightweight unit tests to check 
functionalities  on the client side without invoking RPC calls to a server.

Check this file for server: `grpc_in_production/server/main.go`
Check this file for server test: `grpc_in_production/server/prodinfo_test.go`

Run test using
```bash
# grpc_in_production/server
$ go test .
```
Here we tested `AddProduct` using both HTTP server connection (actually starting a server in gorouting) and 
using mock/buffer (without starting a server). 

If you are developing a gRPC client application with Go, you can use `Gomock` to  mock the client interface 
(using the generated code) and programmatically set its methods to expect and return predetermined values. 
Using `Gomock`, you can generate mock interfaces for the gRPC client application using:
```bash
$ mockgen grpc_prod/proto-gen ProductInfoClient > mock_prodinfo/prodinfo_mock.go
```

Here, we’ve specified `ProductInfoClient` as the interface to be mocked. Then the test code you write can 
import the package generated by `mockgen` along with the `gomock` package to write unit tests around client-side logic.

Package generated by mockgen: `grpc_in_production/mock_prodinfo/prodinfo_mock.go`
Package for testing mockgen generated package: `grpc_in_production/mock_prodinfo/prodinfo_mock_test.go`

```bash
# ProductInfoClient interface inside productinfo_grpc.pb.go
# this will be mocked in prodinfo_mock.go generated package

type ProductInfoClient interface {
	AddProduct(ctx context.Context, in *Product, opts ...grpc.CallOption) (*ProductID, error)
	GetProduct(ctx context.Context, in *ProductID, opts ...grpc.CallOption) (*Product, error)
}
```

In practice, you can verify a selected set of capabilities via mocking and the rest needs to be verified against 
the actual gRPC server implementation.

## Load Testing
we need tailor-made load-testing tools that can load test the gRPC server by generating a virtual load of RPCs to the server.

`ghz` is such a load-testing tool; it is implemented as a command-line utility using Go. 
It can be used for testing and debugging services locally, and also in automated continuous integration environments for performance regression testing.

```bash
ghz --insecure \
--proto ./greeter.proto \
--call helloworld.Greeter.SayHello \
-d '{"name":"Joe"}'\
-n 2000 \
-c 20 \
0.0.0.0:50051
```